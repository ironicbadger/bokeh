# Implementation Plan: Photo Management Application

**Branch**: `001-photo-management` | **Date**: 2025-09-15 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/001-photo-management/spec.md`

## Summary
Build a containerized photo management application with Next.js frontend and Python image processing backend, supporting RAW/HEIF formats, with infinite scroll grid view, virtual scrolling, and efficient batch photo ingestion for libraries of 10,000+ photos.

## Technical Context
**Language/Version**: TypeScript/Next.js 14+, Python 3.11+  
**Primary Dependencies**: Next.js, React, PostgreSQL, Pillow, pillow-heif, rawpy, Docker  
**Storage**: PostgreSQL 15+ for metadata, filesystem for photos/thumbnails  
**Testing**: Playwright (containerized), pytest for Python services  
**Target Platform**: Docker containers (Linux), web browsers  
**Project Type**: web (frontend + backend with Python services)  
**Performance Goals**: <2s initial load, <500ms subsequent pages, <100ms image navigation  
**Constraints**: <200ms p95 response time, efficient memory for 100k+ photos, container-only dev  
**Scale/Scope**: 10k-100k photos, 10+ concurrent users, 3 container architecture

## Constitution Check
*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

**Simplicity**:
- Projects: 3 (frontend, backend-api, python-services)
- Using framework directly? Yes (Next.js, FastAPI/Flask)
- Single data model? Yes (shared between services)
- Avoiding patterns? Yes (direct DB access, no unnecessary abstractions)

**Architecture**:
- EVERY feature as library? Yes - image processing, ingestion, thumbnail generation
- Libraries listed:
  - image_processor: Handle RAW/HEIF/standard formats
  - metadata_extractor: Extract EXIF and generate hashes
  - thumbnail_generator: Multi-size thumbnail creation
  - directory_scanner: Scan and import photo directories
  - job_queue: Background job processing
- CLI per library: Each Python service exposes CLI interface
- Library docs: Will use docstrings and --help

**Testing (NON-NEGOTIABLE)**:
- RED-GREEN-Refactor cycle enforced? Yes
- Git commits show tests before implementation? Yes
- Order: Contract→Integration→E2E→Unit strictly followed? Yes
- Real dependencies used? Yes (PostgreSQL, actual file system)
- Integration tests for: API contracts, photo ingestion, thumbnail generation

**Observability**:
- Structured logging included? Yes
- Frontend logs → backend? Yes (unified stream)
- Error context sufficient? Yes

**Versioning**:
- Version number assigned? 0.1.0 (MVP)
- BUILD increments on every change? Yes
- Breaking changes handled? N/A for initial version

## Project Structure

### Documentation (this feature)
```
specs/001-photo-management/
├── plan.md              # This file
├── research.md          # Phase 0 output
├── data-model.md        # Phase 1 output
├── quickstart.md        # Phase 1 output
├── contracts/           # Phase 1 output (OpenAPI specs)
└── tasks.md             # Phase 2 output (generated by /tasks)
```

### Source Code (repository root)
```
# Web application structure (frontend + backend)
backend/
├── src/
│   ├── models/
│   │   ├── photo.py
│   │   ├── user.py
│   │   ├── folder.py
│   │   └── job.py
│   ├── services/
│   │   ├── auth_service.py
│   │   ├── photo_service.py
│   │   └── job_service.py
│   ├── api/
│   │   ├── v1/
│   │   │   ├── photos.py
│   │   │   ├── folders.py
│   │   │   ├── auth.py
│   │   │   └── system.py
│   │   └── main.py
│   └── python/
│       ├── image_processor.py
│       ├── metadata_extractor.py
│       ├── thumbnail_generator.py
│       ├── directory_scanner.py
│       └── job_queue.py
└── tests/
    ├── contract/
    ├── integration/
    └── unit/

frontend/
├── src/
│   ├── components/
│   │   ├── GridView/
│   │   ├── ImageViewer/
│   │   ├── FolderTree/
│   │   ├── StatusBar/
│   │   └── Settings/
│   ├── pages/
│   │   ├── api/
│   │   ├── index.tsx
│   │   └── viewer/
│   ├── hooks/
│   ├── store/
│   └── lib/
└── tests/
    └── playwright/

database/
├── migrations/
└── init/

docker/
├── Dockerfile
├── Dockerfile.dev
├── docker-compose.yml
├── docker-compose.dev.yml
└── docker-compose.test.yml
```

**Structure Decision**: Option 2 (Web application) based on Next.js frontend + Python backend requirements

## Phase 0: Outline & Research

### Research Tasks Required:
1. **Container orchestration**: Best practices for multi-service Docker setup with Next.js and Python
2. **Image processing pipeline**: Optimal approach for RAW/HEIF processing in Python
3. **Virtual scrolling**: Implementation patterns for React with 10k+ items
4. **Database optimization**: PostgreSQL indexing strategies for photo metadata
5. **Job queue**: Background processing patterns for Python in containers
6. **WebP generation**: Fallback strategies and browser compatibility
7. **File watching**: Efficient directory monitoring in containerized environment
8. **Authentication**: JWT implementation with Next.js and Python backend

### Key Decisions to Research:
- FastAPI vs Flask for Python API layer
- React Query vs SWR for data fetching
- Bull vs custom job queue implementation
- Sharp vs Python Pillow for thumbnail generation
- PostgreSQL JSONB indexing strategies

**Output**: research.md with all technical decisions resolved

## Phase 1: Design & Contracts

### Planned Artifacts:
1. **data-model.md**: 
   - Photo, User, Folder, Thumbnail, Job, Gallery entities
   - Relationships and constraints
   - JSONB schema for metadata

2. **contracts/**:
   - OpenAPI specification for all endpoints
   - Request/response schemas
   - Error response formats

3. **quickstart.md**:
   - Docker setup instructions
   - Initial photo import workflow
   - Basic usage guide

4. **Contract tests**:
   - API endpoint validation
   - Schema compliance tests
   - Authentication flow tests

5. **CLAUDE.md updates**:
   - Add containerization context
   - Include Python service patterns
   - Document job queue approach

## Phase 2: Task Planning Approach

**Task Generation Strategy**:
- Generate tasks from contracts and data model
- Group by architectural layer (DB → API → Services → UI)
- Mark parallel tasks [P] for independent development
- Ensure TDD approach with tests first

**Task Categories**:
1. **Infrastructure** (5-7 tasks): Docker setup, database init, environment config
2. **Data Layer** (8-10 tasks): Models, migrations, indexes
3. **API Layer** (10-12 tasks): Endpoints, authentication, validation
4. **Python Services** (8-10 tasks): Image processing, scanning, jobs
5. **Frontend Components** (12-15 tasks): Grid, viewer, navigation, settings
6. **Integration** (5-7 tasks): E2E flows, performance testing

**Estimated Output**: 50-60 numbered, ordered tasks optimized for LLM-driven development

## Complexity Tracking
*No violations identified - using standard web application patterns*

## Progress Tracking

**Phase Status**:
- [x] Phase 0: Research complete
- [x] Phase 1: Design complete
- [x] Phase 2: Task planning approach defined
- [ ] Phase 3: Tasks generated (/tasks command)
- [ ] Phase 4: Implementation complete
- [ ] Phase 5: Validation passed

**Gate Status**:
- [x] Initial Constitution Check: PASS
- [x] Post-Design Constitution Check: PASS
- [x] All technical context clarified
- [x] Complexity deviations documented (none)

---
*Based on Constitution v2.1.1 - See `/memory/constitution.md`*